---
title: Java后端开发面试题
date: 2024-12-08
slug: java-backend-interview-questions
categories:
  - Java
description: 对 Java、Spring、MySQL、分布式等面试知识的收集
draft: false
lastmod: 2025-03-11
---
## Java

### 特性

Java是一门**面向对象**的编程语言，其具有平台独立性，可移植性和稳健性

### 什么是面向对象？和面向过程有什么区别？

面向对象：通过将现实世界中的事物抽象为**对象**，并通过对象的**属性**和**行为**来组织程序，以提高程序的可读性、复用性和维护性。

| 特性     | 面向对象                       | 面向过程                       |
| -------- | ------------------------------ | ------------------------------ |
| 核心思想 | 强调对象和类，数据和行为一体化 | 强调过程和逻辑，数据与行为分离 |
| 组织方式 | 通过对象                       | 通过函数                       |
| 代码复用 | 通过继承与组合实现             | 通过函数调用实现               |
| 扩展性   | 更高，通过多态和继承扩展功能   | 较低，需修改源代码             |
| 现实模拟 | 更贴近现实                     | 不够直观                       |

### 面向对象的四大特性？

1.**封装**，将对象的属性和方法隐藏起来，仅通过提供的接口与外界交互，隐藏实现细节，便于维护，增强代码安全性; 
2.**继承**，子类通过继承来获得父类的属性与方法，并可自己添加或修改，便于复用; 
3.**多态**，同一个方法在不同对象中有不同表现形式，实现方式有：方法重载，方法重写和父类引用指向子类对象，提高代码灵活性和扩展性; 
4.**抽象**，提取多个对象的共性，抽象类和接口。

### 接口和抽象类的区别？

抽象类是对象的模板或蓝图，接口则是定义了一种行为

### Java基本数据类型：

| 简单类型  | byte | char      | short | int     | long | float | double | boolean |
| ----- | ---- | --------- | ----- | ------- | ---- | ----- | ------ | ------- |
| 二进制位数 | 8    | 16        | 16    | 32      | 64   | 32    | 64     | 取决于JVM  |
| 包装类   | Byte | Character | Short | Integer | Long | Float | Double | Boolean |

### 为什么需要包装类？

因为 Java 很多地方需要使用对象，比如集合类中，我们无法将int，double等数据类型放进去，因为集合的容器要求元素必须是对象; 包装类还添加了属性和方法，丰富了基本类型的操作。

### String为什么不可变

1.String是被 `private final` 修饰的 `char` 数组，并且没有对外提供修改的方法。
2.不可变的好处：**线程安全**，同一个 String 可被多个线程共享; **支持 hash 映射和缓存**，String 的 hash 值常被用到，如作为 Map 的 key ，不用重新计算 hash 值; **安全考虑**：URL，file path 和密码之类的数据常用String 保存; **字符串常量池优化**，String 对象创建后，会被放入字符串常量池，下次需要同样的对象时可直接返回常量池中的引用。

### String，StringBuffer，StringBuilder

String 不可变，Buffer 和 Builder 可变; String 和 Buffer 是线程安全的，Builder 不是; Buffer 内部使用 `synchronized` 同步。

### 多线程的实现方式，他们之间的区别，用多线程怎么选择？

### Java中的堆和栈区别，关系和生命周期

## Spring

### Spring Boot 启动类的注解，在启动过程中做了那些事，在 ioc 容器中的过程

启动类注解：`@SpringBootApplication` 

### Spring boot 或 Spring 框架中的设计模式

### 什么是事务，有什么特点？

***事务***：是用户定义的一个数据库操作序列

特性：***ACID***

1. ***原子性（Atomicity）***：事务中的所有操作不可分割，要么同时成功，要么同时失败，有一个操作失败，其他成功的操作都需要回滚
2. ***一致性（Consistency）***：事务必须确保数据库从一个一致状态转为另一个一致状态，即使系统出现故障
3. ***隔离性（Isolation***：多个事务并发时，事务彼此之间互不影响
4. ***持久性（Durability）***：事务一旦提交，它对数据库的改变是永久的

***一致性***：事务执行前后，数据库必须处于完整性约束未被违反的有效状态

***数据完整性规则*** 包括：***实体完整性***（如主键唯一性）、***参照完整性***（如外键约束）、***域完整性***（如字段范围限制）、自定义完整性（如业务约束）

### Spring 事务隔离级别

***事务隔离级别***：是一个事务对数据的修改与另一个并行的事务的隔离程度

当高并发状态下，多个事务访问相同的数据时，若没有采取必要且合理的隔离机制，则可能发生以下问题：

| 问题                              | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| 脏读（Dirty Read）                | 一个事务能够读取到另一个尚未提交的事务所修改的数据，若未提交的事务后来被回滚，那么第一个事务读取到的数据就是无效的或“脏”的 |
| 幻读（Phantom Read）              | 一个事务对**相同的数据集**查询两次，但由于其他并发的事务同时修改了数据并提交，导致两次查询的结果集不同 |
| 不可重复读（Non-repeatable Read） | 一个事务读取**同一行**数据时，第一次读取和第二次读取的结果不同 |

幻读与不可重复读的区别：

- ***不可重复读*** 关注的是 **同一行数据** 在事务内多次读取时的变化。
- ***幻读*** 关注的是 **满足查询条件的一组行** 在事务内多次查询时的变化，特别是由于其他事务的插入或删除操作导致的结果集差异。

Spring 事务的隔离级别：

| 隔离级别                     | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| 默认（DEFUALT）              | 使用与数据库的隔离级别                                       |
| 读未提交（READ_UNCOMMITTED） | 最低的隔离级别                                               |
| 读已提交（READ_COMMITTED）   | 可解决 ***脏读***，Oracle 默认采取                           |
| 可重复读（REPEATABLE_READ）  | 可解决 ***脏读***，***不可重复读***，MySQL 默认采取          |
| 串行化（SERIALIZABLE）       | 可解决 ***脏读***，***不可重复读***，***幻读***，最高的隔离级别，所有事务依次执行，对性能的影响十分巨大 |

## 数据库

### MySQL 表设计

## 中间件

> 客户端与服务器之间，或在程序各个模块之间起连接、协作和处理功能的软件组件或服务。
> 常见功能包括：
> 1.请求处理：请求在进入应用服务之前或返回给客户端前，执行一些处理，如验证、日志记录等
> 2.缓存：减少直接访问数据库，提升响应
> 3.消息队列：分布式系统中为各个服务提供异步的消息传递，助于解耦
> 4.数据库连接池
> 5.事务管理：确保多个操作的原子性、隔离性和一致性

### 缓存

使用缓存需要注意的问题：

1. 数据一致性：当数据发生更改后，如何保证该数据的缓存也及时更改，保持与其一致。
2. 缓存管理策略：合理地配置缓存的过期时间、缓存清理策略、缓存大小等，尤其是在高并发环境下。
3. 可能的缓存失效：在高并发，高流量的应用中，需要做好缓存穿透和雪崩的防范措施，避免缓存失效带来的问题。
   1. 缓存穿透：查询请求直接穿过缓存，访问到后端的数据库或者其他数据源，而没有命中缓存，通常是因为缓存中没有对应的值。
   2. 雪崩：缓存中的大量数据在同一时间过期，导致大量的请求同时访问数据库，导致数据库崩溃。

## 设计模式

## 分布式
### CAP定理

一个分布式系统至多只能同时满足以下三个条件中的两个
1.一致性（Consistency）：指强一致性，强调数据的绝对正确。当一个写操作成功后，系统中所有节点应都能读取到最新的数据，若是写操作失败，所有节点也都不能读到这个数据。
2.可用性（Availability）：系统提供的服务时刻处于100%可用，对每一个用户的请求都能在有限时间内返回结果，不能超时或拒绝。
3.分区容错性（Partition Tolerance）：即使因为故障导致分布式系统中部分节点失效，此时系统也要持续对外提供服务。
常见情况：在分布式系统中，系统不可能保证100%不出故障，而服务又必须能时刻对外提供服务时，`P` 则需要被满足。但保证了 `P`，`A`和 `C` 便只能选一个。

### SPring Cloud 常用组件

- **服务注册与发现（Service Registry and Discovery）**：
    - **Eureka**：​由 Netflix 开发的服务注册与发现组件，允许服务实例在启动时注册自身，并使其他服务能够发现并与之通信。
    - **Nacos**：
- **负载均衡（Load Balancing）**：
    - **Ribbon**：​客户端负载均衡器，提供多种负载均衡策略，使服务调用者能够以均衡的方式访问多个服务实例。
    - **Sentinel**
- **断路器（Circuit Breaker）**：
    - **Hystrix**：​由 Netflix 开发的熔断器组件，用于处理服务调用中的故障，防止故障蔓延，增强系统的容错性和稳定性。
- **API 网关（API Gateway）**：
    - **Zuul**：​提供动态路由、监控、弹性负载和安全功能的 API 网关，作为服务入口，管理和路由请求到后端服务。
    - **Spring Gateway**
- **配置管理（Configuration Management）**：
    - **Spring Cloud Config**：​集中式配置管理工具，支持为分布式系统中的各个微服务提供外部化配置，简化配置的管理和维护。

## DDD
